#summary understanding the map xml format
#labels Featured

<wiki:toc max_depth="2" />

= Introduction =

Cumberland provides an xml format that you can use to store and load maps.  It details such information as projection, layer data sources, symbology, and so forth.  Users may find it simpler to create their maps through xml, instead of through the API.  Additionally, the [drawmap] and [tilepyramider] command line tools requires this as input.

The map xml format is not a strict schema, in that any missing or out of place element will not cause it to fail.  It just looks for certain elements and ignores the rest.

= Xml Document structure =

== The Map Element ==

The xml document should be prefaced as usual and have a 'Map' element at the root level:

{{{
<?xml version="1.0" encoding="utf-8"?>
<Map version="0.1">
...
}}}

Applying the "version" attribute to the map forces cumberland to check the version.  If not set, cumberland will try to parse the xml.  If set, but to a version not supported, cumberland will throw an exception.

This element supports several child elements:

{{{
<Width>400</Width>
<Height>400</Height>
<Extents>-120,12,-82,34</Extents>
<Projection>+init=epsg:4326</Projection>
<Layers>
...
</Layers>
}}}

The Width/Height set the size of the image to draw in pixels.  The Projection defines the output projection of the map.  The extents define the portion of the map to draw.  Layers can hold zero to many 'Layer' elements.

== Layer Elements ==

A layer encompasses a single data source along with symbology information which tells the map drawer how to render it.  It supports the following child elements:

{{{
<Layer>
    <Id>states</Id>
    <Projection>+init=epsg:4326</Projection>
    <Theme>NumericRange</Theme>
    <ThemeField>AREA</ThemeField>
    <Data ...>
        ...
    </Data>
    <Styles>
        ...
    </Styles>
</Layer>
}}}

The Id element is simply a holder you can put a name or unique id in for your own reference.  The Projection element holds the coordinate system of the underlying data.  The Theme and ThemeField are used for theming.  The 'Theme' specifies the type of theming to do, and the 'ThemeField' specifies the field in the underlying data source to do the theming on.

== The 'Data' Element ==

This element stores information about the feature source.  It is extendable in that new feature source types can be created and references to their data stored.  To let cumberland know the type, there are two attributes that must be set:

  * sourceType - specifies the type of feature source this is (database, file) 
  * sourceInstance - specifies the actual feature source type (PostGIS, shapefile)

The inner content within this element is dependent on it's sourceType attribute.  For example a shapefile data element looks as so:

{{{
<Data sourceType="Cumberland.Data.IFileFeatureSource" sourceInstance="Cumberland.Data.Shapefile.Shapefile">
    <FilePath>../shape_eg_data/mexico/states.shp</FilePath>
</Data>
}}}

Note the relative path to the shapefile.  If a relative path is used, it is expected to be relative to the map xml file path.  This can be used for bundling up resources without having to worry about mangled file paths.

A database data element looks like this:

{{{
<Data sourceType="Cumberland.Data.IDatabaseFeatureSource" sourceInstance="Cumberland.Data.PostGIS.PostGISFeatureSource">
    <ConnectionString>Server=192.168.1.107;Port=5432;User Id=pguser;Password=pgpublic;Database=florida;</ConnectionString>
    <TableName>springs_fdep_2000</TableName>
</Data>
}}}

_Note: there are other optional parameters for database feature sources that can be used for doing subqueries.  There is an example [http://code.google.com/p/cumberland/source/browse/trunk/cumberland/Cumberland.Tests/maps/postgis.xml here]._

Additionally, you can use the SimpleFeatureSource class to create an inline feature source ([http://code.google.com/p/cumberland/source/browse/trunk/cumberland/Cumberland.Tests/maps/simplefeatures.xml example here]).

== Style elements ==

The 'Styles' element, within the 'Layer' element can have zero to many 'Style' elements.  These affect how the features in the feature source are drawn.  If there is no Layer.Theme element or it is set to 'None', then the first Style element is used.  If theming is enabled, then the style element that is used depends on if the feature matches parameters specified within the style.  If there is no matching style for the feature, the feature is not drawn.

The possible child elements for 'Style' are:

{{{
<Style>
    <FillColor>255,100,255,100</FillColor>
    <LineColor>255,0,155,0</LineColor>
    <LineSize>1</LineSize>
    <LineStyle>Solid</LineStyle>
    <PointSize>5</PointSize>
    <PointSymbol>Shape</PointSymbol>
    <PointSymbolShape>Square</PointSymbolShape>
    <PointSymbolImagePath>images/city_icon.png</PointSymbolImagePath>
    <MinRangeThemeValue>0</MinRangeThemeValue>
    <MaxRangeThemeValue>500000</MaxRangeThemeValue>
    <UniqueThemeValue>Rio Grande de Santiago</UniqueThemeValue>
</Style>
}}}

Most of these are obvious.  They describe how a feature should be drawn given it's type (point, polygon, polyline).  The format for colors is 'A,R,G,B'.  The ThemeValue properties are used in conjunction with the Layer.Theme and Layer.ThemeField to determine whether a style applies to a feature.  

= Examples =

That's the basics of the map xml format.  Several example maps are stored in the source:

[http://code.google.com/p/cumberland/source/browse/#svn/trunk/cumberland/Cumberland.Tests/maps]