#summary a tile pyramid generator for popular web mapping applications
#labels Featured

<wiki:toc max_depth="2" />

= Introduction =

Most modern web mapping interfaces use tiles.  This has the advantage of allowing the tiles to be pre-generated instead of per-user.  Tilepyramider generates a pyramid of tile images into a directory structure that you can use with these interfaces.  The output can be copied to your web server.  

Supported tile consumers:

  * Google Maps ([http://www.salmonsalvo.net/Cumberland:GoogleMapsTest demo])
  * TileMapService (TMS) - can be used in OpenLayers (new to 0.2) ([http://salmonsalvo.net/Cumberland:_OpenLayers_Test demo])
  * Microsoft VirtualEarth (new to 0.2) ([http://salmonsalvo.net/Cumberland:_VirtualEarth_Test demo])

= Usage = 

Tilepyramider is a command line utility, its usage is as follows:

{{{
Usage: [mono] tilepyramider.exe [OPTIONS]+ "path to map file" 
Generates a pyramid of tile images for use for popular web mapping interfaces

example: mono tilepyramider.exe  /path/to/map 

Options:
  -e, --extents=VALUE        comma-delimited extents for clipping tile generation (e.g. -180,-90,180,90).  Overrides the map file.  (Must be in map's coordinate system)
  -h, --help                 show this message and exit
  -o, --output=VALUE         the path of the where to create.  Defaults to current directory
  -x, --maxzoom=VALUE        the maximum zoom level
  -n, --minzoom=VALUE        the minimum zoom level
  -t, --test                 Test - only calculate the total and return
  -c, --consumer=VALUE       The consumer.  Valid values are 'googlemaps', 'tms'.
  -w, --worldextents=VALUE   comma-delimited extents for defining world (e.g. -180,-90,180,90). Valid only for TMS
  -b, --bleed=VALUE          the bleed in pixels for tiles (useful for catching overrunning symbols/labels from other tiles
}}}

The "map file" is defined by the [mapXmlFormat map xml format] which holds data sources and style information.  This generates a set of images in the output folder specified.  If no output folder is specified, the tiles are generated in the current directory.  The worldextents, maxzoom, and minzoom options are only for customizing TMS output.

== Setting a bleed ==

The bleed option provides the ability to have the tool render a larger map and crop it to size.  This way it can catch features whose symbology may extend across a tile.

= Deployment: Google Maps =

In order to use Google Maps on your website, you will need a key ([http://code.google.com/apis/maps/signup.html sign up here]).  Finally, you will need to add the html and script to your web page:

Add a div element for the map:

{{{
<div id="map_canvas" style="width: 500px; height: 300px"></div>
}}}

And in the head, a reference to google maps script (replace with your key):

{{{
<script src="http://maps.google.com/maps?file=api&amp;v=2&amp;key={your key}"   type="text/javascript"></script>
}}}

Next, the script to load the map and tile overlay:

{{{
<script type="text/javascript">

function initialize() 
{
	if (GBrowserIsCompatible()) 
	{
		var map;
	        map = new GMap2(document.getElementById("map_canvas"));
	        map.setCenter(new GLatLng(24.5, -81.7), 9);
	        map.addControl(new GSmallMapControl());
	        map.addControl(new GMapTypeControl());
	        
		var tileLayerOverlay = new GTileLayerOverlay(
			new GTileLayer(null, null, null, {
			    tileUrlTemplate: '/tiles/reefs/{Z}/{X}_{Y}.png', 
			    isPng:true,
			    opacity:1.0
			  })
			);
			
		map.addOverlay(tileLayerOverlay);
	}
}
</script>

}}}

You'll need to point map.setCenter to the center longitude/latitude of where you want your map (and at what zoom level).  Also, the GTileLayerOverlay.tileUrlTemplate property should be set to the path where you uploaded your tiles generated by tilepyramider.  This property is used by Google Maps to acquire tiles (it replaces the {Z},{X},{Y} with the tile coordinates as requested).

Finally, handle loading/unloading in the html body element:

{{{
<body onload="initialize();" onunload="GUnload();">
}}}

== Clipping to tile boundaries ==

If your tiles are not worldwide, then you will want to filter out any tile requests.  To do this you'll need to set the GTileLayer.getTileUrl property instead of the tileUrlTemplate:

{{{
var tl = new GTileLayer(null, null, null, {
    isPng:true,
    opacity:1.0
    });
tl.getTileUrl = CustomGetTileUrl;

var tileLayerOverlay = new GTileLayerOverlay(tl);
map.addOverlay(tileLayerOverlay);
}}}

This method will be responsible for filtering tile requests:

{{{
function CustomGetTileUrl(point,zoom)
{
	if (zoom > 16)
	{
		return 'blanktile.png';
	}

	// Define our tile boundaries
	// Note: origin in google maps is top-left
	var minLL = new GLatLng(24.67,-81.99);
	var maxLL = new GLatLng(24.29,-81.48);

	// convert our lat/long values to world pixel coordinates
	var currentProjection = G_NORMAL_MAP.getProjection();
	var minPixelPt = currentProjection.fromLatLngToPixel(minLL, zoom);
	var maxPixelPt = currentProjection.fromLatLngToPixel(maxLL, zoom);

	// convert our world pixel coordinates to tile coordinates 

	var minTileCoord = new GPoint();
	minTileCoord.x = Math.floor(minPixelPt.x / 256);
	minTileCoord.y = Math.floor(minPixelPt.y / 256);

	var maxTileCoord = new GPoint();
	maxTileCoord.x = Math.floor(maxPixelPt.x / 256);
	maxTileCoord.y = Math.floor(maxPixelPt.y / 256);

	// filter out any tile requests outside of our bounds
	if (point.x < minTileCoord.x || 
			point.x > maxTileCoord.x ||
			point.y < minTileCoord.y ||
			point.y > maxTileCoord.y)
	{
		return 'blanktile.png';
	}


	return 'reefs/' + zoom + '/' + point.x + '_' + point.y + '.png';
}
}}}

Basically, it shows a blank image tile whenever the map is out of scale or the tile requested is not within our bounds.  You'll need to edit this to fit your scale/bounds requirements.

= Deployment: Virtual Earth = 

Your page will need to reference the VE script:

{{{
<script charset="UTF-8" type="text/javascript" src="http://dev.virtualearth.net/mapcontrol/mapcontrol.ashx?v=6.2"></script>
}}}

Add a method for adding your tile overlay:

{{{
function init()
{
    var map = new VEMap('myMap');
    map.LoadMap(new VELatLong(21,-100), 3, null, null, null, null, null, null);

    var bounds = [
        new VELatLongRectangle(new VELatLong(34,-120),
                new VELatLong(12,-82))];
    var layerID = "test";
    var tileSource =
        "ve/%4.png";
    var tileSourceSpec =
        new VETileSourceSpecification(layerID, tileSource);
    tileSourceSpec.NumServers = 1;
    tileSourceSpec.Bounds     = bounds;
    tileSourceSpec.MinZoom    = 1;
    tileSourceSpec.MaxZoom    = 5;
    tileSourceSpec.Opacity    = 1;
    tileSourceSpec.ZIndex     = 110;

    map.AddTileLayer(tileSourceSpec, true);
}
}}}

tileSource should point to the directory that tilepyramider created.  Finally, call that method and create the map div:

{{{
<body onload="init();">
<div id='myMap' style="position:absolute; width:400px; height:400px;"></div>
...
}}}

= Deployment: TMS to Open Layers =

TMS is an OSGeo specification, but our use is mainly for OpenLayers.  Currently, a TMS has to have an EPSG of 4326 and worldwide extents to work in OpenLayers ([http://openlayers.org/pipermail/users/2008-April/005449.html source]). This means you can't clip to a certain region.  So, your map must be outputting geographic data (lat/longs), and then you could call the tool as so:

{{{
tilepyramider.exe -e=-180,-90,180,90 -o=/home/scottell/Desktop/tms -c=tms -x=6 ../../../Cumberland.Tests/maps/mexico.xml
}}}

Then you'll deploy the resulting 'tms' directory to your website and wire up a page with the following script:

{{{
function initialize()
{
    var options = {
        maxExtent: new OpenLayers.Bounds(-180, -90, 180, 90),
            numZoomLevels: 6,
    };

    var map = new OpenLayers.Map('map', options);
    var layer = new OpenLayers.Layer.TMS( "Mexico", ["http://localhost/~scottell/"],
    {
        layername: 'tms',
        serviceVersion: '',
        type:'png',
    } );
   
    map.addLayer(layer);
    map.setCenter(new OpenLayers.LonLat(-105, 24), 4);
}
}}}

Add a script reference to OpenLayers:

{{{
<script src="http://www.openlayers.org/api/OpenLayers.js" type="text/javascript"></script>
}}}

Finally, call initialize() on load and add your map div:

{{{
<body onload="initialize()">
    <div id="map" style="width: 500px; height: 300px"></div>
}}}

